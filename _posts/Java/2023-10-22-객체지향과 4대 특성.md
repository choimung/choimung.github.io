---

title: 객체지향과 4대 특성
date: 2023-10-22 12:15:00 +0900
categories: [Java]
tags: [Java]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---
객체지향의 기본개념을 복습하기 위하여 글을 작성하였습니다.

## 💬 객체란 무엇일까?
객체란 물리적으로 존재하거나 개념적인것 중에서 다른 것과 식별 가능한 것을 객체라고 말한다.

- 물리적인 객체 : 자동차, 자전거, 휴대폰, 강아지   
  이들은 실제로 존재하며 우리 주변에서 식별 가능하다.

- 개념적인 객체 : 수학공식, 학과, 주문, 강의   
  이들은 실체가 없지만 추상적인 개념을 나타내며 식별 가능하다.

객체는 속성과 동작으로 이루어져 있다. '사람'객체를 예로 들어보자.

- 속성 : 이름, 나이, 성별
- 동작 : 웃다, 먹다, 공부하다

자바에서는 이러한 속성과 동작을 각각 필드와 메소드라고 명칭한다.

## 💬 객체지향의 기본 개념

- 현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져 있다.
- 실제 사물의 속성과 기능을 분석한다음 데이터와 함수로 정의함으로써 실제 세계를 컴퓨터로 옮겨놓은것이다.   
  우리는 이것을 객체 모델링 이라고 이야기한다.

![](../../../../assets/img/2023-10-22-13-37-50.png)

객체지향에서 말하는 객체는 2번째 정의와 비슷한 개념이라고 말할 수 있다.

## 💬 인간의 사고 방식과 객체지향

인간은 주변 환경을 **사물** 단위로 인식한다.

외부로 나가 주위를 살펴보면 아파트, 행인, 강아지, 자동차 등 다양한 사물이 눈에 들어온다.

이 사물을 이해하고 인식할 때, 일반적으로 우리는 먼저 전체적인 부분을 파악하고 이후 

세부적인 부분을 조사하며 사물을 인식해나간다.

예를 들어, 강아지를 보면 "강이지다" 라는 전체적인 부분을 파악한 후,   

"검은색이네" 라는 세부적인 부분을 조사하고 "품종은 허스키 같아"와 같이 더 자세한 정보를 얻게 된다.

이런식으로 대상을 부분이 아닌 하나의 **사물** 로써 인식하는 것이 보편적이다.  

이러한 사물은 다양한 속성을 가지며 동시에 특정한 행위 또는 기능이 가능하다.

강아지는 견종, 몸무게, 털색, 출생연도 등의 속성을 가지며 먹다, 자다 등의 행위가 가능한 대상이 될 수 있다.


```java
class Dog{
	int age;
	int weight;
	String color;
	String name;

	public void eat(){
		...
	}

	public void sleep(){
		...
	}
}
```

```java
Dog.eat();
```

이제 우리는 강아지를 객체로써 표현할 수 있다.

`Dog` 클래스는 강아지의 속성과 행위를 정의하고 있다.

객체지향 프로그래밍을 활용하면 현실 세계의 사물을 코드로 자연스럽게 표현할 수 있다.

사물을 객체로 옮기면 코드는 훨씬 표현력이 좋아지며, 주어와 동사 형태가 더 자연스럽고 직관적으로 표현된다.


## 💬 객체의 유효성

**객체는 생성 시점부터 소멸 시점까지 항상 유효한 데이터를 가져야 한다.**

우리가 작성한 `Dog` 클래스에는 생성자가 없기 때문에 

객체를 생성하면 모든 멤버변수가 해당 변수 타입의 맞는 초기값으로 초기화 될 것이다.

색상, 몸무게, 나이 정보가 없는 강아지는 없을 것이다.

즉 유효하지 않은 데이터를 가진 객체가 생성된 것이다.

```java
class Dog{
	int age;
	int weight;
	String color;

	public Dog(int age, int weight, color){
		this.age = age;
		this.weight = weight;
		this.color = color;
	}

	public void eat(){
		...
	}

	public void sleep(){
		...
	}
}

```

이전에 만들었던 `Dog` 클래스에 생성자를 추가하여 인스턴스 생성 시 부터 유효한 데이터를 갖을 수 있도록 수정하였다.

이젠 `Dog` 클래스 객체를 생성할 때에는 반드시 인자를 넣어 모든 멤버 변수를 초기화 해야한다.

하지만 아직도 유효하지 않은 값이 들어갈 수 있다.

```java
new Dog(9999,-99999,"rainbow");
```

나이가 `9999`살이고 몸무게가 `-99999` 이며 색상이  `rainbow`인 강아지는 세상에 없을것이다.

```java
public Dog(int age, int weight, color){
	if(weight < 0 || weight > 100 ){
		throw new IllegalArgumentException();
	}
	this.age = age;
	this.weight = weight;
	this.color = color;
}
```

위 소스코드 처럼 생성자내에서 조건문을 이용하여 유효하지 않은 값이 들어왔을때 객체를 생성할 수 없게하였다.

## 💬 객체의 의인화

현실에서는 사람이 자동차를 운전한다. 코드로 표현하면 다음과 같다.

```java
Person.drive(car);
```

그러나 객체 지향에서는 다음과 같이 표현하는 것이 일반적이다.

```java
car.drive();
```

위 코드는 마치 자동차가 인간처럼 스스로 움직이는것 같은 표현 방법이다.

**객체지향에서는 생명체든 비생명체든 모두 자아를 가지고 스스로 동작할 수 있는 존재라고 생각하자.**

이를 **객체 의인화**라고 한다.

객체는 데이터와 해당 데이터를 처리하는 메서드를 함께 가지며  이를 통해 스스로 상태를 관리하고 특정한 기능을 수행할 수 있다.   

이러한 의인화는 코드를 더 직관적이고 자연스럽게 만들어주며, 객체 간의 상호작용이 더 유연하고 효과적으로 이루어지도록 한다.

또 객체가 마치 실제로 존재하는 것처럼 다양한 동작을 수행할 수 있어 코드를 이해하고 유지보수가 쉬워진다.


## 💬 객체지향의 4대 원칙

### 1.추상화(Abstraction)

현실에 존재하는 객체를 프로그래밍 세계로 옮기기 위해서는  
우선 사물의 속성과 기능이 무엇인지 생각하는 과정이 필요하다.

사물이 가진 모든 속성과 동작을 코드로 옮기는것이 가능할까?   
→ 불가능하다.

자동차가 가진 부품의 수가 약 3만 개에 달한다고 한다.   
이 모든 것을 코드로 표현하는 것은 현실적으로 불가능하며 필요하지도 않다.

인간은 자동차를 볼 때 세세한 부품까지 생각하지 않는다.  
"자동차네" → "검정색이다" → "제조사는 BMW이네"

인간은 무의식적으로 대부분의 정보를 생략하고, 관심있는 정보만을 인식한다.

추상화는 구체화의 반대말이다.

구체적인 것은 현실에 존재하는, 즉 프로그래밍에 옮겨올려고 하는 객체가 될 것이며   

추상적인 것은 코드로 옮겨진 객체가 될 것이다.

추상화란 구체적 → 추상적으로 만드는 과정을 말한다.   

현실에 존재하는 사물을 가진 속성과 기능중에서 필요한 것만 추출하여 코드로 옮기는 과정이다.
![](../../../../assets/img/2023-10-22-14-04-16.png)


### 2.캡슐화(Encapsulation)

객체의 필드와 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말한다.

외부 객체는 객체 내부의 구조를 알지 못하며 외부의 잘못된 사용으로 객체가 손상되지 않도록 하는데 있다.

```java
class Person {
	int age;
	String firstName;
	String lastName;
	int height;
	int birthYear;

	public void eat() {
		System.out.printf("%s is eating\n", this.firstName + this.lastName);
	}
	public void sleep() {
		System.out.printf("%s is sleeping\n", this.firstName + this.lastName);
	}
	public void work() {
		System.out.printf("%s is working\n", this.firstName + this.lastName);
	}
}
```

`person` 이라는 클래스는 사람이 가는 모든 속성을 추출하는것이 아니라

프로그램에서 꼭 필요한 기능만을 추출하여 모델링(추상화)을 한 뒤, 클래스로 묶어서 캡슐화를 한 것이다.  

- 추상화는 실제세계의 객체에 대해 필요한 속성과 기능을 추출하는 것
- 캡슐화는 추출한 속성들을 실제 클래스로 옮겨 클래스라는 캡슐에 담는것

접근제어자를 통해 클래스에 담은 속성과 동작들을 외부에 노출여부를 정할 수 있다.   

```java
class Person {
	private int age;
	private String firstName;
	private String lastName;
	private int height;
	private int birthYear;

	public void eat() {
		System.out.printf("%s is eating\n", this.firstName + this.lastName);
	}
	public void sleep() {
		System.out.printf("%s is sleeping\n", this.firstName + this.lastName);
	}
	public void work() {
		System.out.printf("%s is working\n", this.firstName + this.lastName);
	}
}

Person p = new Person("John", "Doe", 49);
p.work(); // ok
p.age; // Compile Error
```

`private` 접근 제어자로 선언된 멤버변수에 외부에서 직접적으로 접근하면 컴파일 오류가발생한다. 

반대로 `public` 접근 제어자로 선언된 메소드는 정상적으로 작동할 것이다.   

이런식으로 객체를 생성했을 때, 외부에서 접근할 수 있는 속성,메소드를 제한하여  외부에서 직접적으로 접근하는것을 방지할 수 있다.   

객체는 생성부터 소멸될때 까지 유효한 값을 가져야한다고 말했었다.

만약 외부에서 직접적으로 필드에 접근하여 비정상적인 값으로 수정하게된다면 원칙에 위반이 되는것이다.

접근 제어자를 `private` 으로 제한하고 `getter` `setter` 로 외부에서 읽기, 쓰기를 동작할 수 있도록한다.  

이제 외부에서 `getter` 를 통해 값을 일고 `setter` 를 통해 값을 수정할 수 있다.

`setter` 메소드에서 유효성검사를 하는 로직을 추가하여 유효하지않은 데이터가 들어가는것을 방지할 수 있다.

## 3. 상속(Inheritance)
 
상속은 자기가 가지고있는 필드와 메소드를 자식에게 물려주는것을 말한다.

상속을 이용하면 코드의 재사용성을 높일 수 있고 유지 보수 시간을 최소화 시켜준다.

잘 개발된 부모의 객체를 필드와 메소드를 자식이 그대로 사용할 수 있어 자식 객체에서 중복 코딩을 하지 않아된다.

부모 객체의 필드와 메소드를 수정하면 자식 객체들은 수정된 필드와 메소드를 그대로 사용할 수 있다.

예를 들어 강아지가 동물의 특징과 기능을 상속 받았다면 '강아지는 동물이다'가 성립된다.

이경우 동물은 `class` 이고 강이지는 `instance` 가 된다. 

```java
Animal Dog = new Animal("강아지");
```

하지만 `Animal` 은 다양한 종을 포함한다.  

강아지와, 고양이는 같은 동물이지만 다른 속성과 동작을 가지기 때문에

`Animal` 이라는 추상적인 class만으로는 이를 표현할 수 없다.   

보다 구체적인 강아지, 고양이 클래스가 필요하다.

```java
class Dog {
	int age;
	int height;
	int weight;

	void bite() {
		System.out.println("물다");
	}
}

class Cat {
	int age;
	int height;
	int weight;

	void climb() {
		System.out.println("나무에 오르다");
	}
}
```
이제 보다 구체적인 `dog`, `cat` 클래스가 만들어지고 고유의 동작을 갖게되었다.  

그러나 둘 다 동물이기 때문에 겹치는 속성이 존재한다.   

상속을 통해서 중복을 제거할 수 있다.

```java
class Animal {
	int age;
	int height;
	int weight;
}

class Dog extends Animal {
	void bite() {
		System.out.println("물다");
	}
}

class Cat extends Animal {
	void climb() {
		System.out.println("나무에 오르다");
	}
}
```

상속을 받게되면 해당 부모가 가진 속성을 모두 물려받게된다. 

`Dog` 와 `Cat`은 모두 `Animal` 을 상속했기 때문에 age, height, weight 를 작성하지 않았지만 모두 갖게된다.  

`Dog` 와 `Cat` 은 자식클래스가 되고 `Animal` 은 부모 클래스가 된다.   

class와 속성이 늘어날 수록 상속을 통한 중복 제거는 유지 보수에 큰 이점이된다.

### 4.다형성(Polymorphism)

다형성은 여러가지 형태를 다질 수 있는 능력이다.

```java
class Animal {
    void makeSound() {
        System.out.println("동물 소리를 내다");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("멍멍! (강아지 소리)");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("야옹! (고양이 소리)");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myPet = new Dog();
        myPet.makeSound(); // "멍멍! (강아지 소리)"
        
        myPet = new Cat();
        myPet.makeSound(); // "야옹! (고양이 소리)"
    }
}
```

`myPet`은 `Animal` 클래스 타입의 변수로 자식타입의 객체를 참조함으로써 다형성을 구현하고있다.   

즉 Mypet타입의 변수로 강아지가 될 수 있고 고양이가 될 수 있다는 의미이다.

---

[참고]
[https://www.mainfn.dev/184fb1c9-5cf1-4fff-a692-5dce63408146](https://www.mainfn.dev/184fb1c9-5cf1-4fff-a692-5dce63408146)