---

title: 객체지향과 4대 특성
date: 2023-10-22 12:15:00 +0900
categories: [Java]
tags: [Java]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---
---

# 객체지향의 기본 개념

  - 실제 세계는 객체(사물)로 이루어져있으며 발생하는 모든 사건들은 사물간에 상호 작용이다   
  - 실제 사물의 속성과 기능을 분석한다음 데이터 와 함수로 정의함으로써 실제 세계를 컴퓨터로 옮겨놓은것이다.
  - 유형의 객체 : 책상, 의자, 자동차, Tv
  - 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념

![](../../../../assets/img/2023-10-22-13-37-50.png)

- **객체지향에서 말하는 객체는 2번째 정의와 비슷한 개념이라고 말할 수 있다.**



<hr>

# 인간의 사고 방식과 객체지향

인간은 세상 모든 것을 **‘사물’** 단위로 바라본다.   
밖에서 나와서 주위를 둘러보자..   
아파트, 행인, 강아지, 자동차.. 등이 보일 것이다.

인간은 주변의 사물을 인식하고 이해할 때 일반적으로 그 사물의 먼저 전체적인부분을 파악하고,   
이후 세부적인 부분을 조사하며 그것을 인식해나간다.   
→ 강아지다? → 검은색이네 → 품종은 허스키 같아. 

이런식으로 대상을 부분이 아닌 하나의 **사물**로써 인식할 것이다.

사물은 다양한 
**속성**을 가지면서 동시에 특정한 **행위(기능)**가 가능하다.   
강아지는 → 견종, 몸무게, 털색, 출생연도, 등의 **속성**을 가지며   

먹다, 자다 등의 **행위**가 가능한 대상이다.

```java
class Dog{
	int age;
	int weight;
	String color;
	String name;

	public void eat(){
		...
	}

	public void sleep(){
		...
	}
}
```

```java
Dog.eat();
```

**사물을 객체로 옮기니 표현력이 훨씬 좋아지고 주어.동사 형태가 훨씬 자연스럽고 직관적이다.**

---

# 객체의 유효성

**객체는 생성 시점부터 소멸 시점까지 항상 유효한 데이터를 가져야 한다.**

우리가 작성한 `Dog` 라는 클래스에는 생성자가 없기 때문에,    
객체를 생성(인스턴스화) 하면 모든 멤버 변수가 각 변수타입의 맞는 초기값으로 초기화 될 것이다.

하지만 강아지 색상,몸무게,나이 가 없는 강아지는 없을 것이다.   
즉 유효하지 않은 데이터를 가진 객체(사물)가 생성된 것이다.

**객체은 항상 생성부터 소멸 시점까지 유효한 데이터를 가져야 한다.**

```java
class Dog{
	int age;
	int weight;
	String color;

	public Dog(int age, int weight, color){
		this.age = age;
		this.weight = weight;
		this.color = color;
	}

	public void eat(){
		...
	}

	public void sleep(){
		...
	}
}

```

이전에 만들었던 `Dog` 클래스에 생성자를 추가하여 인스턴스 생성 시 부터 유효한 데이터를 갖을 수 있도록 수정하였다.

이젠 Dog 클래스 객체를 생성할 때에는 반드시 인자를 넣어 모든 멤버 변수를 초기화 해야한다.

하지만 아직도 유효하지 않은 값이 들어갈 수 있다.

```java
new Dog(9999,-99999,"rainbow");
```

나이가 9999살이고 몸무게가 -99999 이며 색상이 rainbow인 강아지는 없을것이다.

```java
	public Dog(int age, int weight, color){
		if(weight < 0 || weight > 100 ){
				throw new IllegalArgumentException();
		}
		this.age = age;
		this.weight = weight;
		this.color = color;
	}
```

위 소스코드 처럼 생성자내에서 조건문을 이용하여 유효하지 않은 값이 들어왔을때 객체를 생성할 수 없게하였다.

---

# 객체의 의인화

현실에서는 사람이 자동차를 운전한다. 코드로 표현하면 다음과 같다.

```java
Person.drive(car);
```

그러나 객체 지향에서는 다음과 같이 표현하는 것이 일반적이다.

```java
car.drive();
```

위 코드는 마치 자동차가 인간처럼 스스로 움직이는것 같은 표현 방법이다.

**객체지향에서는 생명체든 비생명체든 모두 자아를 가지고 스스로 동작할 수 있는 존재라고 생각하자.**

만약 현실에서 일어나는 일련의 과정을 코드로 완전히 동일하게 작성하면 말도 없이 장황해진다.

```java
person.pickUp(carKey); // 차 키를 집어든다.

person.put(person.carKey).in(car); // 집어든 차 키를 차에 꽂는다.

person.openDoorOf(car); // 문을 연다.

person.getIn(car); // 차에 탄다.

person.start(car); // 시동을 건다.

person.stepOn(car.pedal); // 엑셀을 밟는다.
```

자동차를 의인화하고 중간 과정을 생략하면 이를 `Car.drive();` 한 줄로 축약 할 수 있기 때문에 훨씬 합리적이다.

---

# 객체지향의 4대 원칙

## 1.추상화(Abstraction)

현실에 존재하는 객체(사물)을 프로그래밍 세계로 옮기기는 위해서는,   
우선 사물의 속성과 기능이 무엇인지 생각하는 과정이 필요하다.

하지만 사물이 가진 모든 속성과 동작을 코드로 옮기는것이 가능할까?    
→ 불가능하다. 

자동차가 가진 부품의 수가 약 3만개에 달한다고 한다.   
이 모든것은 코드로 표현할 수 없고 그럴필요가 없다.

인간은 자동차를 볼때 세세한 부품까지 생각하지않는다.

- 자동차가 있네? → 검정색이다 → 제조사는 BMW네 →비싸겠다.

인간은 무의식적으로 대부분의 정보는 생략하고 관심 있는, 필요한 정보만 인식한다.

추상화는 구체화의 반대말이다.   
구체적인것은 현실에 존재하는 즉 프로그래밍에 옮겨올라고 하는 객체(사물)이 될것이다.    
추상적인 것은 코드로 옮겨진 객체(사물)이 될것이다.

추상화란 구체적 → 추상적으로 만드는 과정을 말한다.   
즉, 현실에 존재하는 사물을 가진 속성과 기능중에서 필요한 것만 추출하여 코드로 옮기는것이라고 할 수 있다.
![](../../../../assets/img/2023-10-22-14-04-16.png)
```java
car.drive();
```
객체(자동차)를 의인화하고 기능(drive)를 추상화하여 가독성을 크게 높일 수 있다.

---
## 2.캡슐화(Encapsulation)
캡슐화는 간단히 말해서 변수와 함수를 하나로 묶는것을 말한다.   
즉, 속성과 기능을 클래스로 묶어서 만드는 것을 캡슐화다.  
추상화를 통해 현실세계의 객체의 속성과 기능중에 필요한 것을 추출하여,  
이를 클래스로 옮기면 **추상화** 와 **캡슐화**를 한 것이다.

```java
class Person {
	int age;
	String firstName;
	String lastName;
	int height;
	int birthYear;

	public void eat() {
		System.out.printf("%s is eating\n", this.firstName + this.lastName);
	}
	public void sleep() {
		System.out.printf("%s is sleeping\n", this.firstName + this.lastName);
	}
	public void work() {
		System.out.printf("%s is working\n", this.firstName + this.lastName);
	}
}
```

`person` 이라는 클래스는 인간이 가진 모든 속성을 추출하는것이아니라    
프로그램에서 꼭 필요한 기능만을 추출하여 모델링(추상화)을 한 뒤, 클래스로 묶어서 캡슐화를 한 것이다.  

다시 정리하자면   
- 추상화는 실제세계의 객체에대해 꼭 필요한 속성과 기능을 추출   
- 캡슐화는 추출한 속성들을 실제 클래스로 옮겨 클래스라는 캡슐에 담는것이다.

이 때, 접근제어자를 통해 클래스에 담은 속성과 동작들을 외부에 노출하지 않도록 숨길 수 있다.   
-> 이를 정보 은닉이라고 부른다.

```java
class Person {
	private int age;
	private String firstName;
	private String lastName;
	private int height;
	private int birthYear;

	public void eat() {
		System.out.printf("%s is eating\n", this.firstName + this.lastName);
	}
	public void sleep() {
		System.out.printf("%s is sleeping\n", this.firstName + this.lastName);
	}
	public void work() {
		System.out.printf("%s is working\n", this.firstName + this.lastName);
	}
}

Person p = new Person("John", "Doe", 49);
p.work(); // ok
p.age; // Compile Error
```

위와 같이 `private` 접근 제어자로 선언된 멤버변수에 외부에서 직접적으로 접근하면 컴파일 오류가발생한다.   
반대로 `public` 접근 제어자로 선언된 메소드는 정상적으로 작동할 것이다.   

이런식으로 객체를 생성했을 때, 외부에서 접근할 수 있는 속성,메소드를 제한하여   
외부에서 직접적으로 접근하는것을 방지할 수 있다.   
-> 객체는 생성부터 소멸될때 까지 유효한 값을 가져야한다.   
-> 만약 외부에서 직접적으로 접근하여 비정상적인값으로 수정하면? -> 원칙에 위반인된다.

접근 제어자를 `private` 으로 제한하고 `getter``setter` 로 외부에서 읽기, 쓰기를 동작할 수 있도록한다.   
이제 외부에서 `getter` 를 통해 값을 일고 `setter` 를 통해 값을 수정할 수 있다.  
`setter` 메소드에서 유효성검사를 하는 로직을 추가하여 유효하지않은 데이터가 들어가는것을 방지할 수 있다.

---

## 3. 상속(Inheritance)
쉽게 생각해서 '강아지'를 떠올려보자.   

강아지는 동물이라는 '종'안에 '강아지'라는 개체가 속한다.   
이경우 동물은 class 이고 강이지는 instance 가 된다.       
```java
Animal Dog = new Animal("강아지");
```

하지만 `Animal` 은 다양한 종을 포함한다.   
강아지와, 고양이는 같은 동물이지만 다른 속성과 동작을 가지기 때문에   
`Animal` 이라는 추상적인 class만으로는 이를 표현할 수 없다.   

보다 구체적인 강아지, 고양이 클래스가 필요하다.

```java
class Dog {
	int age;
	int height;
	int weight;

	void bite() {
		System.out.println("물다");
	}
}

class Cat {
	int age;
	int height;
	int weight;

	void climb() {
		System.out.println("나무에 오르다");
	}
}
```
이제 보다 구체적인 `dog`, `cat` 클래스가 만들어지고 고유의 동작을 갖게되었다.  
그러나 둘 다 동물이기 때문에 겹치는 속성이 존재한다.   

상속을 통해서 중복을 제거할 수 있다.

```java
class Animal {
	int age;
	int height;
	int weight;
}

class Dog extends Animal {
	void bite() {
		System.out.println("물다");
	}
}

class Cat extends Animal {
	void climb() {
		System.out.println("나무에 오르다");
	}
}
```

상속을 받게되면 해당 부모가 가진 속성을 모두 물려받게된다.   
`Dog` 와 `Cat`은 모두 `Animal` 을 상속했기 때문에 age, height, weight 를 작성하지 않았지만 모두 갖게된다.  

`Dog` 와 `Cat` 은 자식클래스가 되고 `Animal` 은 부모 클래스가 된다.   

class와 속성이 늘어날 수록 상속을 통한 중복 제거는 유지 보수에 큰 이점이된다.

## 4.다형성(Polymorphism)

다형성은 여러가지 형태를 다질 수 있는 능력이다.

```java
class Animal {
    void makeSound() {
        System.out.println("동물 소리를 내다");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("멍멍! (강아지 소리)");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("야옹! (고양이 소리)");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myPet = new Dog();
        myPet.makeSound(); // "멍멍! (강아지 소리)"
        
        myPet = new Cat();
        myPet.makeSound(); // "야옹! (고양이 소리)"
    }
}
```

`myPet`은 `Animal` 클래스 타입의 변수로 자식타입의 객체를 참조함으로써 다형성을 구현하고있다.   
즉 Mypet타입의 변수로 강아지가 될 수 있고 고양이가 될 수 있다는 의미이다.

---

[참고]
[https://www.mainfn.dev/184fb1c9-5cf1-4fff-a692-5dce63408146](https://www.mainfn.dev/184fb1c9-5cf1-4fff-a692-5dce63408146)