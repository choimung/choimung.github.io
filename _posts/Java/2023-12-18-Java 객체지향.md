---

title: Java 객체지향 프로그래밍 정리
date: 2023-12-18 14:24:00 +0900
categories: [Java]
tags: [Java]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---

## 절차지향 프로그래밍 VS 객체지향프로그래밍
프로그래밍 방식은 크게 절차지향 프로그래밍과 객체지향 프로그래밍 2가지 방식으로 나눌 수 있다.

### 절차지향 프로그래밍
- 절차지향 프로그래밍은 이름 그대로 '절차'를 지향한다. 쉽게 이야기하여 실행 순서를 중요하게 생각하는 방식이다.
- 프로그램의 흐름을 순차적으로 따르며 처리한다. **"어떻게"**를 중심으로 프로그래밍을 한다.

### 객체지향 프로그래밍
- 이름 그대로 '객체'를 지향한다. 쉽게 이야기하여 객체를 중요하게 생각하는 방식이다.
- 실제 세계의 사물이나 사건을 객체로 보고 이러한 객체들의 상호작용을 중심으로 프로그래밍을 하는 방식이다.
- **"무엇을"** 를 중심으로 프로그래밍을 한다.

### 이 둘의 중요한 차이
- 절차지향은 데이터와 해당 데이터를 처리하는 기능이 분리되어 있다.
- 객체지향은 데이터와 그 데이터를 처리하는 기능이 하나의 **객체**안에 포함되어 있다.

<br>

## **그렇다면 객체지향에서 이야기하는 '객체'란 무엇일까?**

먼저 **사전적의미로** 객체는 실세계의 존재하거나 생각할 수 있는 것을 객체라고 말한다.

흔히 볼 수 있는 책상, 의자, 전화기 같은 사물은 물론이고 강의, 수강 신청 같은 개념으로 존재하는것도 모두 객체이다.

　　　

**물리적으로 존재하는 객체와 개념적으로 존재하는 객체를 예를 들어보자.**

- 물리적으로 존재하는 객체의종류
   - 자동차, 자전거, 휴대폰, 강아지, 아파트  
   - 이들은 실제로 존재하며 우리 주변에서 식별이 가능한 구체적인 사물들이다.

- 개념적으로 존재하는 객체의종류
  - 수학공식, 학과, 주문, 강의
  - 이들은 실체가 없지만 추상적인 개념을 나타내며 식별이 가능하다.

<br>

**프로그래밍에서 말하는 객체**는 현실 세계의 실체나 개념을 소프트웨어적으로 모델링 하여 추상화한 것이다.

실세계의 모든 객체를 단순하게 추상화해보면 속성과 기능으로 나눌 수 있다.

> 현실 세계의 객체를 컴퓨터를 옮기는 과정을 '객체 모델링' 이라고 한다.

<br>

**자동차**
- 속성 : 차량 색상, 현재 속도
- 기능 : 엑셀, 브레이크, 창문 열기, 창문 닫기

<br>

**동물**
- 속성 : 색상, 키, 온도
- 기능 : 먹는다, 걷는다

<br>

이러한 객체는 속성과 기능을 갖고 있으며 자바에서는 속성을 필드, 기능을 메서드라고 표현한다.
<br>

## 객체의 상호작용	
현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져 있다.

커피숍에서 커피를 주문한다고 예를 들어보자.

### ☕ 예) 커피 주문


<hr>
**객체 : 고객, 바리스타, 커피 머신, 커피 컵**

- 고객 : 커피를 주문하는 주체로, 주문 내용을 결정한다.

- 바리스타 : 주문된 커피를 만드는 역할을 하는 사람 또는 기계이다.

- 커피 머신 : 커피를 추출하거나 가열하는 기계로, 바리스타의 지시에 따라 작동한다.

- 커피 컵 : 만들어진 커피를 담는 용기로, 고객에게 제공된다.

<hr>

**상호작용**

- 주문 : 고객이 바리스타에게 원하는 커피를 주문한다.

- 제조 : 바리스타는 주문을 받고, 커피 머신을 사용하여 주문된 커피를 제조한다.

- 전달 : 바리스타가 만든 커피를 커피 컵에 담아 고객에게 전달한다.

- 수령 : 고객은 주문한 커피를 수령하고 카페를 떠난다.
  
<hr>

이처럼 객체의 상호작용은 간단하고 일상적인 상황에서도 일어난다.

프로그래밍에서도 이러한 객체 간의 상호작용을 모델링하여 객체 지향 프로그램을 개발할 수 있다.

객체 지향 프로그램에서 객체들의 상호작용 수단은 **메서드** 이다. 메서드 호출을 통해 데이터를 주고받는 것이 가능하다

<br>

###  🖥️ 객체지향 프로그래밍(OOP)

정리해보자면 실제 세계의 객체를 컴퓨터로 옮겨와 추상화하여 속성과 기능으로 정의하고 이러한 객체들의 상호작용을 중심으로 프로그래밍 하는 방식을 객체지향 프로그래밍이라고 한다.

<hr>
<br>

## 🏗️ 객체와 클래스

현실 세계에서 자동차를 생성하려면 자동차의 설계도가 필요하듯이,

객체지향 프로그래밍에서도 객체를 생성하려면 설계도에 해당하는 **클래스**가 필요하다.

클래스는 객체를 생성하기 위한 일종의 설계도로, 객체의 속성과 메서드를 정의한다.

이 클래스를 기반으로 실제 메모리에 할당되어 사용되는 것이 객체의 인스턴스이다.

객체지향 프로그래밍에서는 이러한 인스턴스를 생성하는 과정을 '인스턴화' 라고하며

이 과정을 통해 클래스에 정의된 속성과 메서드를 갖는 실제 객체가 생성된다.

<br>

## 🛒 클래스의 구성 멤버

  **필드(field)**
  - 필드와 변수는 프로그래밍에서 데이터를 저장하는데 사용되는 개념이지만 맥락과 의미에서 차이가있다.
  - 객체의 데이터를 저장하는 역할을 한다.
  - 필드는 클래스 내부에 선언되어 객체의 속성(상태)을 나타내는 변수이다.

  **메서드(method)**
  - 클래스 내에서 정의된 함수로, 객체의 동작이나 행위를 정의한다.
  - 객체와 객체간의 상호작용을 위해 호출된다.

  **생성자(construcor)**
  - new 연산자로 객체를 생성할때 객체의 초기화 역학을 담당하는 특별한 메소드이다.

<br>

## 📁 인스턴스 멤버와 정적 멤버
필드와 메소드는 선언 방법에 따라 인스턴스 멤버, 정적 멤버로 분류 할 수 있다.

인스턴스 멤버는 객체 생성 후 사용할 수 있고, 정적 멤버는 객체 생성 없이도 사용할 수 있다.

### 인스턴스 멤버(Instance Member)
- 선언 위치 : 클래스 내부에서 선언되며, 인스턴스 변수 및, 인스턴스 메서드를 의미한다.
- 사용 방법 : 해당 클래스의 인스턴스를 생성한 후에 사용할 수 있다.
- 생명 주기 : 인스턴스의 생성과 소멸에 따라 동적으로 생성되고 소멸한다.

### 정적 멤버(Instance Member)
- 선언 위치 : 클래스 내부에서 `static` 키워드로 선언되며, 정적 변수 및 정적 메서드를 의미한다.
- 사용 방법 : 객체 생성 없이 클래스 이름을 통해 직접 접근하여 사용할 수 있다.
- 생명 주기 : 프로그램이 실행되면서 클래스가 메모리에 로딩될 때 생성되고 프로그램 종료시 소멸된다.

<br>

## ✨ 객체지향의 4대 원칙

### 🧱 1.추상화(Abstraction)

추상화는 현실 세계의 복잡한 객체를 단순화하여 컴퓨터세계로 옮겨오는것을 말한다.

객체를 정의할 때 객체가 가져야 하는 속성과 기능에 중점을 두어 구체적인 세부사항을 무시한다.

###  추상화의 예시:
현실 세계의 자동차를 추상화
- 속성 : "색상", "속도", "모델"
- 기능 : "정지", "주행", "속도 조절"
- 자동차의 부품은 약 3만개에 달한다고 하지만 추상화를 통해 속성과 기능에 중점을 두어 모델링을하였다.

학생 추상화
- 속성 : 학번, 이름, 전공
- 기능 : 수업 참여, 시험 응시, 성적 확인
- 추상화를 통해 학생 객체를 정의하고 학생의 핵심 정보와 행동을 나타낼 수 있다.

<hr>

추상화는 구체화의 반대말이다.

구체적인 것은 현실에 존재하는, 즉 프로그래밍에 옮겨올려고 하는 객체가 될 것이며   

추상적인 것은 코드로 옮겨진 객체가 될 것이다.

<p align="center">
  <img src="../../../../assets/img/2023-10-22-14-04-16.png">
</p>

<br>

### 💊 2.캡슐화(Encapsulation)

객체의 필드와 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말한다. (정보은닉)

외부 객체는 객체의 내부 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메서드만 사용가능하다.

캡슐화는 객체의 내부 구현을 외부로부터 감춤으로써 안정성과 보안성을 높이는데 기여한다.

접근제어자를 통해 클래스에 담은 속성과 동작들을 외부에 노출여부를 정할 수 있다.

<hr>

#### Getter / Setter

객체는 생성부터 소멸때 까지 유효한 값을 가져야한다.

`private` 접근 제어자로 선언된 멤버변수에 외부에서 직접접으로 접근하면 컴파일 오류가 발생하게된다.

외부에서 직접적으로 필드에 접근하여 비정상적인 값으로 수정하게 된다면 객체는 비정상적인 값을 가질 수 있게 된다.

필드의 접근제어를 `private` 으로 제한하고 `getter` `setter` 메서드을 열어두어 외부에서 읽고 쓰기를 동작하게한다. 

이제 외부에서 `getter` 를 통해 값을 읽고 `setter` 를 통해 값을 수정할 수 있다.

`setter` 메소드에서 유효성검사를 하는 로직을 추가하여 유효하지않은 데이터가 들어가는것을 방지할 수 있다.

<br>

### 👶 3.상속(Inheritance)

상속은 객체 지향 프로그래밍에서 자식 클래스가 부모 클래스의 속성과 메소드를 물려받는 개념을 말한다. 

이를 통해 코드의 재사용성을 높이고 유지 보수 시간을 최소화 할 수 있다.

**주요 특징**
- 코드 재사용성 증가 : 부모 클래스에서 정의한 필드와 메소드를 자식 클래스에서 그대로 사용할 수 있다.
- 확장성제공 : 자식 클래스는 부모 클래스의 기능을 물려받으면서 필요에 따라 새로운 필드나 메서드 추가 가능하다.
- 유지보수 : 부모 클래스의 필드나 메서드가 수정하면 이를 물려받은 모든 자식클래스는 변경사항이 반영된다.
  
```java
//부모 클래스
class Animal {
    // 부모 클래스의 필드
    String name;

    // 부모 클래스의 메소드
    void eat() {
        System.out.println(name + "이(가) 먹습니다.");
    }
}

//자식 클래스
class Dog extends Animal {
    // 자식 클래스의 추가 필드
    String breed;

    // 자식 클래스의 추가 메소드
    void bark() {
        System.out.println(name + "이(가) 짖습니다. 멍멍!");
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        // 자식 클래스의 인스턴스 생성
        Dog myDog = new Dog();

        // 부모 클래스의 필드 사용
        myDog.name = "멍멍이";
        // 부모 클래스의 메소드 호출
        myDog.eat();

        // 자식 클래스의 추가 필드 사용
        myDog.breed = "골든 리트리버";
        // 자식 클래스의 추가 메소드 호출
        myDog.bark();
    }
}
```

<br>

### 📚 4.다형성(Polymorphism)

다형성은 하나의 인터페이스나 클래스가 여러 형태로 동작할 수 있는 능력을 의미한다.



```java
class Animal {
    void makeSound() {
        System.out.println("동물 소리를 내다");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("멍멍! (강아지 소리)");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("야옹! (고양이 소리)");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myPet = new Dog();
        myPet.makeSound(); // "멍멍! (강아지 소리)"
        
        myPet = new Cat();
        myPet.makeSound(); // "야옹! (고양이 소리)"
    }
}
```

`myPet`은 `Animal` 클래스 타입의 변수로 자식타입의 객체를 참조함으로써 다형성을 구현하고있다.   

즉 Mypet타입의 변수로 강아지가 될 수 있고 고양이가 될 수 있다는 의미이다.

---
