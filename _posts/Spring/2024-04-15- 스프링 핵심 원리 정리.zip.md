---
title: 스프링 핵심 원리 정리.zip
date: 2024-04-15 12:25:00 +0900
categories: [Spring]
tags: [Spring]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---

## 📌 스프링이란?

**스프링이란 어떤 특정한 하나의 기술이 아닌 여러 스프링 기술들의 모임이라고 생각할 수 있다.**

![](../../../../assets/img/2024-04-15-16-54-01.png)

위 사진 외에도 스프링 프레임워크를 확장하고 보완하는 라이브러리들이 존재한다.

> ### 프레임워크란 ?
> 프레임워크는 소프트웨어 개발을 위한 구조와 규칙을 제공하는 도구나 환경을 말한다.   
> 프레임워크를 이용하면 개발자가 애플리케이션을 빠르고 효율적으로 개발할 수 있도록 돕는 역할을 한다.

> ### 라이브러리란 ?
> 재사용 가능한 코드와 기능들의 집합으로 특정한 작업이나 기능을 수행하기 위해 개발된 프로그램의 부분.  
> 일반적으로 라이브러리는 함수, 클래스, 모듈, 혹은 패키지 형태로 제공되며 개발자가 불러와 사용가능하다.   
> 개발자가 동일한 작업을 반복해서 구현할 필요가 없으며 이미 구현된 기능을 불러와 사용가능하다.   
> ex) 데이터베이스 연결, 네트워크 통신, 보안 기능 등 다양한 작업을 수행하는 라이브러리가 존재한다.

---
<br>

### 📌 스프링의 핵심 개념

- 스프링은 Java 기반의 프레임워크이다.
- Java는 객체 지향 언어로 OOP의 특징은 다음과 같다.
  - 상속, 추상화, 캡슐화, 다형성
- **스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크이다. **
  - 즉 좋은 객체 지향 어플리케이션을 개발 할 수 있도록 도와준다.
  
<br>
---

<br>

### 📌 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- SRP: 단일 책임 원칙 (Single responsibility principle)
  - 하나의 클래스는 하나의 책임을 가져야한다.
  - 하나의 책임이라는것은 기준이 모호하다. 책임이 클 수 도 작을 수도 있다.
  - 가장 중요한 기준은 **변경** 이다. 변경이 있을때 파급효과가 작으면 SRP를 잘 따른것이다.
  
- ⭐ OCP: 개방 - 폐쇄 원칙 (Open - Close principle)
  - 소프트웨어의 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.
  - 자바의 다형성만을 사용하면 OCP 원칙을 지킬 수 없다.
    - 자바에서 구현 객체를 변경하려면 클라이언트의 코드도 변경해야한다.
    - 다형성을 사용하였지만 클라이언트의 코드를 변경해야 하므로 OCP원칙에 위배된다.
    - 별도의 설정자가 필요하며 설정자를 통해 위 문제를 해결할 수 있다. -> 스프링 컨테이너

- LSP - 리스코프 치환 원칙 (Liskov substitution principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
  - 예) 자동차 인터페이스의 엑셀 메서드는 앞으로 가라는 기능이다.
    - 인터페이스를 구현한 구현체가 엑셀의 메서드를 뒤로가게 구현하면 LSP 원칙을 위배한것이다.

- ISP - 인터페이스 분리 원칙 (Interface segregation principle)
  - 인터페이스를 분리하면 인터페이스의 명확도가 높아지고 대체 가능성이 높아진다.

- ⭐DIP : 의존관계 역전 원칙 (Dependency inversion principle)
  - 개발자는 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 의존성 주입은 이 원칙을 따르는 방법 중하나이다.

<br>
---

<br>

### 📌 제어의 역전 IoC (Inversion of Control)

일반적으로 프로그래밍에서 제어권은 개발자가 가지고 있다. `OrderServiceImpl` 클래스를 예시로 들어보자.   

`OrderServiceImpl` 클래스는 `MemberRepository` 와 `DiscountPolicy`에 대하여 직접적으로 생성하고 관리하고 있다.

```java
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
}
```

**하지만 정책 변경으로 구현 객체를 변경해야 된다면? `MemoryMemberRepository` -> `JdbcMemberRepository`**

`OrderServiceImpl` 클래스 내부의 소스코드가 직접적으로 변경해야되니 OCP, DIP 원칙에 위배 될 것이다.

<br>

#### AppConfig 클래스의 등장

새롭게 등장한 `AppConfig` 클래스는 객체의 생성과 관리를 담당하는 클래스이다. 이전에는 `OrderServiceImpl` 클래스 내에서
객체의 생성과 설정을 하여 책임이 해당 클래스에 있었지만 `AppConfig` 클래스의 등장으로 책임이 분리되고 제어권이 넘어갔다.

```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public DiscountPolicy discountPolicy() {
        //return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}

public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
    }
}
```

이를 통해 `OrderServiceImpl` 클래스는 더 이상 객체의 생성과 설정에 대한 책임을 가지지 않게 되었다. 

또 필요한 인터페이스를 호출하지만 어떤 구현 객체들이 주입될지는 모르고 묵묵히 자신의 로직에 따라 실행하게 된다.   

이로써 `OrderServiceImpl` 클래스의 관심사를 분리하였고 소스코드의 제어권을 `AppConfig`에게 위임하였다 이렇게 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것을 **제어의 역전**이라고 부르며
AppConfig 클래스를 Ioc 컨테이너, DI 컨테이너라고 부른다.

<br>

---

<br>

### 📌 DI (Dependency Injection)

> **의존성 주입은 객체가 필요로 하는 의존성을 직접 생성하지 않고 외부에서 주입받는 디자인 패턴이다.**

`OrderServiceImpl` 클래스 내 `memberRepository` 와 `discountPolicy` 는 인터페이스에게만 의존한다. 
실제 어떤 구현객체가 사용될지는 `OrderServiceImpl` 클래스 입장에서는 알 수 없고 애플리케이션이 실행 시점에 외부(AppConfig)에서 실제 구현 객체를 생성하고 생성자를 통해 구현객체가 주입된다.

- DI 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- DI 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

<br>

---

<br>

### 📌 스프링 컨테이너
  
- 스프링 프레임워크에서 DI와 IoC를 담당하는 `ApplicationContext` 를 스프링 컨테이너 라고 부른다.
  
- 스프링 컨테이너는 `Configuration` 어노테이션이 붙은 클래스를 설정 정보로 사용한다.

- 설정 클래스에서 `@Bean` 어노테이션이 붙은 메서드가 호출이 되고 반환된 객체를 스프링 빈으로 등록하게된다.
  - `@Bean` 어노테이션이 붙은 각 메서드의 이름은 해당 스프링 빈의 이름이 된다.
  - `@Bean` 어노테이션이 붙은 각 메서드의 반환된 객체는 스프링 빈의 객체가 된다.

<br>

#### 스프링 컨테이너 생성과정

<br>

##### 1. 스프링 컨테이너 생성

![](../../../../assets/img/2024-04-17-22-32-23.png)

- 스프링 컨테이너는 `new AnnotationConfigApplicationContext(구성클래스.class)` 코드로 생성할 수 있다.
  - 스프링 컨테이너는 XML 또는 어노테이션 기반의 자바 설정 클래스로 설정할 수 있다.

<br>

##### 2. 스프링 빈 등록

![](../../../../assets/img/2024-04-17-22-34-50.png)

- 스프링 컨테이너는 파라미터로 들어온 구성 클래스 정보를 활용하여 스프링 빈을 등록한다.
- `@Bean` 어노테이션이 붙은 메서드를 호출하여 반환된 객체를 스프링 빈으로 등록한다.

<br>

##### 3. 스프링 빈 의존관계 설정 - 준비

![](../../../../assets/img/2024-04-17-22-35-52.png)

- 준비 단계에서는 의존성 주입이 필요한 필드를 모두 찾아낸다.

<br>

##### 4. 스프링 빈 의존관계 설정 - 완료

![](../../../../assets/img/2024-04-17-22-36-24.png)

- 완료 단계에서는 실제 의존성 주입이 이루어진다.

<br>

---

<br>

### 📌 스프링 컨테이너에 등록된 빈 조회

스프링 컨테이너에서 스프링 빈 조회시 대원칙
- 부모 타입으로 조회할 경우 자식 타입의 스프링 빈도 모두 조회가 된다.
- Object 타입으로 조회시 모든 스프링 빈이 조회된다.

<br>

- 빈 이름으로 조회 `ac.getBean("memberService", MemberService.class);`
  - 빈 이름으로 조회시 빈의 이름이 컨테이너에 등록되지 않은 경우 `NoSuchBeanDefinitionException` 발생한다.
  
- 타입으로 조회 `ac.getBean(MemberService.class);`
  - 타입으로 조회시 같은 타입이 둘 이상 있을 경우 `NoUniqueBeanDefinitionException` 발생한다.
  - 동일한 타입이 둘 이상일 경우 빈 이름을 지정해서 조회해야한다.

- 부모 타입으로 조회 `ac.getBean(DiscountPolicy.class);`
  - 부모 타입으로 조회시, 자식 타입이 둘 이상 있을 경우 `NoUniqueBeanDefinitionException` 발생한다.
  - 자식 타입이 둘 이상일 경우 빈 이름을 지정해서 조회해야한다.
  - 또는 특정 구체타입을 지정하여 조회한다. - 지향하기

<br>

---

<br>

### 📌 BeanFactory와 ApplicationContext

![](../../../../assets/img/2024-04-17-22-46-58.png)

- `BeanFactory` : 스프링의 가장 기본적인 컨테이너로, 빈을 등록하고 관리하는 역할을 한다.
  - ac.getBean 메서드 제공
- `ApplicationContext` : BeanFactory를 상속받으며 그 외 다양한 기능을 상속받아 다양한 기능을 제공한다.

- `AnnotationConfigApplicationContext` : JavaConfig를 이용한 설정 클래스를 이용하여 빈을 등록하는 데 특화된 컨테이너이다. `@Configuration` 어노테이션을 사용한 설정 클래스를 이용하여 빈을 등록할 수 있다.