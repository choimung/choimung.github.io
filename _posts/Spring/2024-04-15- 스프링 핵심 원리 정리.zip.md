---
title: 스프링 핵심 원리 정리.zip
date: 2024-04-15 12:25:00 +0900
categories: [Spring]
tags: [Spring]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---

## 📌 스프링이란?

**스프링이란 어떤 특정한 하나의 기술이 아닌 여러 스프링 기술들의 모임이라고 생각할 수 있다.**

![](../../../../assets/img/2024-04-15-16-54-01.png)

위 사진 외에도 스프링 프레임워크를 확장하고 보완하는 라이브러리들이 존재한다.

> ### 프레임워크란 ?
> 프레임워크는 소프트웨어 개발을 위한 구조와 규칙을 제공하는 도구나 환경을 말한다.   
> 프레임워크를 이용하면 개발자가 애플리케이션을 빠르고 효율적으로 개발할 수 있도록 돕는 역할을 한다.

> ### 라이브러리란 ?
> 재사용 가능한 코드와 기능들의 집합으로 특정한 작업이나 기능을 수행하기 위해 개발된 프로그램의 부분.  
> 일반적으로 라이브러리는 함수, 클래스, 모듈, 혹은 패키지 형태로 제공되며 개발자가 불러와 사용가능하다.   
> 개발자가 동일한 작업을 반복해서 구현할 필요가 없으며 이미 구현된 기능을 불러와 사용가능하다.   
> ex) 데이터베이스 연결, 네트워크 통신, 보안 기능 등 다양한 작업을 수행하는 라이브러리가 존재한다.

---


### 📌 스프링의 핵심 개념

- 스프링은 Java 기반의 프레임워크이다.
- Java는 객체 지향 언어로 OOP의 특징은 다음과 같다.
  - 상속, 추상화, 캡슐화, 다형성
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크이다. 
  - 즉 좋은 객체 지향 어플리케이션을 개발 할 수 있도록 도와준다.

---

### 📌 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- SRP: 단일 책임 원칙 (Single responsibility principle)
  - 하나의 클래스는 하나의 책임을 가져야한다.
  - 하나의 책임이라는것은 기준이 모호하다. 책임이 클 수 도 작을 수도 있다.
  - 가장 중요한 기준은 **변경** 이다. 변경이 있을때 파급효과가 작으면 SRP를 잘 따른것이다.
  
- ⭐ OCP: 개방 - 폐쇄 원칙 (Open - Close principle)
  - 소프트웨어의 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.
  - 자바의 다형성만을 사용하면 OCP 원칙을 지킬 수 없다.
    - 자바에서 구현 객체를 변경하려면 클라이언트의 코드도 변경해야한다.
    - 다형성을 사용하였지만 클라이언트의 코드를 변경해야 하므로 OCP원칙에 위배된다.
    - 별도의 설정자가 필요하며 설정자를 통해 위 문제를 해결할 수 있다. -> 스프링 컨테이너

- LSP - 리스코프 치환 원칙 (Liskov substitution principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
  - 예) 자동차 인터페이스의 엑셀 메서드는 앞으로 가라는 기능이다.
    - 인터페이스를 구현한 구현체가 엑셀의 메서드를 뒤로가게 구현하면 LSP 원칙을 위배한것이다.

- ISP - 인터페이스 분리 원칙 (Interface segregation principle)
  - 인터페이스를 분리하면 인터페이스의 명확도가 높아지고 대체 가능성이 높아진다.

- ⭐DIP : 의존관계 역전 원칙 (Dependency inversion principle)
  - 개발자는 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 의존성 주입은 이 원칙을 따르는 방법 중하나이다.

---

### 📌 제어의 역전 IoC (Inversion of Control)

일반적으로 프로그래밍에서 제어권은 개발자가 가지고 있다. `OrderServiceImpl` 클래스를 예시로 들어보자.   

`OrderServiceImpl` 클래스는 `MemberRepository` 와 `DiscountPolicy`에 대하여 직접적으로 생성하고 관리하고 있다.

```java
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
}
```

**하지만 정책 변경으로 구현 객체를 변경해야 된다면? `MemoryMemberRepository` -> `JdbcMemberRepository`**

`OrderServiceImpl` 클래스 내부의 소스코드가 직접적으로 변경해야되니 OCP, DIP 원칙에 위배 될 것이다.

<br>

#### AppConfig 클래스의 등장

새롭게 등장한 `AppConfig` 클래스는 객체의 생성과 관리를 담당하는 클래스이다. 이전에는 `OrderServiceImpl` 클래스 내에서
객체의 생성과 설정을 하여 책임이 해당 클래스에 있었지만 `AppConfig` 클래스의 등장으로 책임이 분리되고 제어권이 넘어갔다.

```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public DiscountPolicy discountPolicy() {
        //return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}

public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
    }
}
```

이를 통해 `OrderServiceImpl` 클래스는 더 이상 객체의 생성과 설정에 대한 책임을 가지지 않게 되었다. 

또 필요한 인터페이스를 호출하지만 어떤 구현 객체들이 주입될지는 모르고 묵묵히 자신의 로직에 따라 실행하게 된다.   

이로써 `OrderServiceImpl` 클래스의 관심사를 분리하였고 소스코드의 제어권을 `AppConfig`에게 위임하였다 이렇게 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것을 **제어의 역전**이라고 부르며
AppConfig 클래스를 Ioc 컨테이너, DI 컨테이너라고 부른다.

---

### 📌 DI (Dependency Injection)

> **의존성 주입은 객체가 필요로 하는 의존성을 직접 생성하지 않고 외부에서 주입받는 디자인 패턴이다.**

`OrderServiceImpl` 클래스 내 `memberRepository` 와 `discountPolicy` 는 인터페이스에게만 의존한다. 
실제 어떤 구현객체가 사용될지는 `OrderServiceImpl` 클래스 입장에서는 알 수 없고 애플리케이션이 실행 시점에 외부(AppConfig)에서 실제 구현 객체를 생성하고 생성자를 통해 구현객체가 주입된다.

- DI 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- DI 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.