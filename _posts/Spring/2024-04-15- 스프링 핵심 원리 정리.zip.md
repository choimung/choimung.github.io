---
title: 스프링 핵심 원리 정리.zip
date: 2024-04-15 12:25:00 +0900
categories: [Spring]
tags: [Spring]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---

## 📌 스프링이란?

**스프링이란 어떤 특정한 하나의 기술이 아닌 여러 스프링 기술들의 모임이라고 생각할 수 있다.**

![](../../../../assets/img/2024-04-15-16-54-01.png)

위 사진 외에도 스프링 프레임워크를 확장하고 보완하는 라이브러리들이 존재한다.

> ### 프레임워크란 ?
> 프레임워크는 소프트웨어 개발을 위한 구조와 규칙을 제공하는 도구나 환경을 말한다.   
> 프레임워크를 이용하면 개발자가 애플리케이션을 빠르고 효율적으로 개발할 수 있도록 돕는 역할을 한다.

> ### 라이브러리란 ?
> 재사용 가능한 코드와 기능들의 집합으로 특정한 작업이나 기능을 수행하기 위해 개발된 프로그램의 부분.  
> 일반적으로 라이브러리는 함수, 클래스, 모듈, 혹은 패키지 형태로 제공되며 개발자가 불러와 사용가능하다.   
> 개발자가 동일한 작업을 반복해서 구현할 필요가 없으며 이미 구현된 기능을 불러와 사용가능하다.   
> ex) 데이터베이스 연결, 네트워크 통신, 보안 기능 등 다양한 작업을 수행하는 라이브러리가 존재한다.

---
<br>

### 📌 스프링의 핵심 개념

- 스프링은 Java 기반의 프레임워크이다.
- Java는 객체 지향 언어로 OOP의 특징은 다음과 같다.
  - 상속, 추상화, 캡슐화, 다형성
- **스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크이다.**
  - 즉 좋은 객체 지향 어플리케이션을 개발 할 수 있도록 도와준다.
  
<br>
---

<br>

### 📌 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- SRP: 단일 책임 원칙 (Single responsibility principle)
  - 하나의 클래스는 하나의 책임을 가져야한다.
  - 하나의 책임이라는것은 기준이 모호하다. 책임이 클 수 도 작을 수도 있다.
  - 가장 중요한 기준은 **변경** 이다. 변경이 있을때 파급효과가 작으면 SRP를 잘 따른것이다.
  
- ⭐ OCP: 개방 - 폐쇄 원칙 (Open - Close principle)
  - 소프트웨어의 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.
  - 자바의 다형성만을 사용하면 OCP 원칙을 지킬 수 없다.
    - 자바에서 구현 객체를 변경하려면 클라이언트의 코드도 변경해야한다.
    - 다형성을 사용하였지만 클라이언트의 코드를 변경해야 하므로 OCP원칙에 위배된다.
    - 별도의 설정자가 필요하며 설정자를 통해 위 문제를 해결할 수 있다. -> 스프링 컨테이너

- LSP - 리스코프 치환 원칙 (Liskov substitution principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
  - 예) 자동차 인터페이스의 엑셀 메서드는 앞으로 가라는 기능이다.
    - 인터페이스를 구현한 구현체가 엑셀의 메서드를 뒤로가게 구현하면 LSP 원칙을 위배한것이다.

- ISP - 인터페이스 분리 원칙 (Interface segregation principle)
  - 인터페이스를 분리하면 인터페이스의 명확도가 높아지고 대체 가능성이 높아진다.

- ⭐DIP : 의존관계 역전 원칙 (Dependency inversion principle)
  - 개발자는 추상화에 의존해야지 구체화에 의존하면 안된다.
  - 의존성 주입은 이 원칙을 따르는 방법 중하나이다.

<br>
---

<br>

### 📌 제어의 역전 IoC (Inversion of Control)

- 일반적으로 프로그래밍에서 제어권은 개발자가 가지고 있다.
- 프로그램의 흐름의 제어흐름을  직접 제어하는것이 아니라 외부에서 관리하는 것을 **제어의 역전**이라고 부른다.
 
<br>

**OrderServiceImpl.java** 
```java
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
}
```
`OrderServiceImpl`는 `MemberRepository` 와 `DiscountPolicy`에 대하여 직접적으로 생성하고 관리하고 있다.

<br>

**하지만 정책 변경으로 구현 객체를 변경해야 된다면?**

- `OrderServiceImpl` 클래스 내부의 소스코드가 직접적으로 변경해야되니 OCP, DIP 원칙에 위배 될 것이다.

<br>

**AppConfig.java**
```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public DiscountPolicy discountPolicy() {
        //return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}

public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
    }
}
```

- AppConfig 클래스는 객체의 생성과 관리를 담당하는 클래스이다.
- 이전에는 OrderServiceImpl 클래스 내에서 객체의 생성과 설정을 하여 책임이 해당 클래스에 있었다.
- AppConfig 클래스의 등장으로 책임이 분리되었고 제어권이 외부로 넘어갔다.
- 이를 통해 `OrderServiceImpl` 클래스는 더 이상 객체의 생성과 설정에 대한 책임을 가지지 않게 되었다. 
- 필요한 인터페이스를 호출하지만 어떤 구현 객체들이 주입될지 모르고 묵묵히 자신의 로직에 따라 실행하게 된다.   

<br>

이로써 `OrderServiceImpl` 클래스의 관심사를 분리하였고 소스코드의 제어권을 `AppConfig`에게 위임하였다 이렇게 프로그램의 제어 흐름을 직접 제어하는것이 아니라 외부에서 관리하는 것을 **제어의 역전**이라고 부르며
AppConfig 클래스를 Ioc 컨테이너, DI 컨테이너라고 부른다.

<br>

---

<br>

### 📌 DI (Dependency Injection)

> **의존성 주입은 객체가 필요로 하는 의존성을 직접 생성하지 않고 외부에서 주입받는 디자인 패턴이다.**

`OrderServiceImpl` 클래스 내 `memberRepository` 와 `discountPolicy` 는 인터페이스에게만 의존한다. 
실제 어떤 구현객체가 사용될지는 `OrderServiceImpl` 클래스 입장에서는 알 수 없고 애플리케이션이 실행 시점에 외부(AppConfig)에서 실제 구현 객체를 생성하고 생성자를 통해 구현객체가 주입된다.

- DI 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- DI 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

<br>

---

<br>

### 📌 스프링 컨테이너
  
- 스프링 프레임워크에서 DI와 IoC를 담당하는 `ApplicationContext` 를 스프링 컨테이너 라고 부른다.
  
- 스프링 컨테이너는 `Configuration` 어노테이션이 붙은 클래스를 설정 정보로 사용한다.

- 설정 클래스에서 `@Bean` 어노테이션이 붙은 메서드가 호출이 되고 반환된 객체를 스프링 빈으로 등록하게된다.
  - `@Bean` 어노테이션이 붙은 각 메서드의 이름은 해당 스프링 빈의 이름이 된다.
  - `@Bean` 어노테이션이 붙은 각 메서드의 반환된 객체는 스프링 빈의 객체가 된다.

<br>

#### 스프링 컨테이너 생성과정

<br>

##### 1. 스프링 컨테이너 생성

![](../../../../assets/img/2024-04-17-22-32-23.png)

- 스프링 컨테이너는 `new AnnotationConfigApplicationContext(구성클래스.class)` 코드로 생성할 수 있다.
  - 스프링 컨테이너는 XML 또는 어노테이션 기반의 자바 설정 클래스로 설정할 수 있다.

<br>

##### 2. 스프링 빈 등록

![](../../../../assets/img/2024-04-17-22-34-50.png)

- 스프링 컨테이너는 파라미터로 들어온 구성 클래스 정보를 활용하여 스프링 빈을 등록한다.
- `@Bean` 어노테이션이 붙은 메서드를 호출하여 반환된 객체를 스프링 빈으로 등록한다.

<br>

##### 3. 스프링 빈 의존관계 설정 - 준비

![](../../../../assets/img/2024-04-17-22-35-52.png)

- 준비 단계에서는 의존성 주입이 필요한 필드를 모두 찾아낸다.

<br>

##### 4. 스프링 빈 의존관계 설정 - 완료

![](../../../../assets/img/2024-04-17-22-36-24.png)

- 완료 단계에서는 실제 의존성 주입이 이루어진다.

<br>

---

<br>

### 📌 스프링 컨테이너에 등록된 빈 조회

- 부모 타입으로 조회할 경우 자식 타입의 스프링 빈도 모두 조회가 된다.
- Object 타입으로 조회시 모든 스프링 빈이 조회된다.
- 빈 이름으로 조회 `ac.getBean("memberService", MemberService.class);`
  - 빈 이름으로 조회시 빈의 이름이 컨테이너에 등록되지 않은 경우 `NoSuchBeanDefinitionException` 발생한다.
  
- 타입으로 조회 `ac.getBean(MemberService.class);`
  - 타입으로 조회시 같은 타입이 둘 이상 있을 경우 `NoUniqueBeanDefinitionException` 발생한다.
  - 동일한 타입이 둘 이상일 경우 빈 이름을 지정해서 조회해야한다.

- 부모 타입으로 조회 `ac.getBean(DiscountPolicy.class);`
  - 부모 타입으로 조회시, 자식 타입이 둘 이상 있을 경우 `NoUniqueBeanDefinitionException` 발생한다.
  - 자식 타입이 둘 이상일 경우 빈 이름을 지정해서 조회해야한다.
  - 또는 특정 구체타입을 지정하여 조회한다. - 지향하기

<br>

---

<br>

### 📌 BeanFactory와 ApplicationContext

![](../../../../assets/img/2024-04-17-22-46-58.png)

- `BeanFactory` : 스프링의 가장 기본적인 컨테이너로, 빈을 등록하고 관리하는 역할을 한다.
  - ac.getBean 메서드 제공
- `ApplicationContext` : BeanFactory를 상속받으며 그 외 다양한 기능을 상속받아 다양한 기능을 제공한다.

- `AnnotationConfigApplicationContext` : JavaConfig를 이용한 설정 클래스를 이용하여 빈을 등록하는 데 특화된 컨테이너이다. `@Configuration` 어노테이션을 사용한 설정 클래스를 이용하여 빈을 등록할 수 있다.

<br>

---

<br>

### 📌 웹 어플리케이션과 싱글톤

웹 어플리케이션은 여러 고객들이 동시에 요청하는 경우가 많다.

이전에 만들었던 순수한 DI 컨테이너인 `AppConfig`를 사용하면 발생되는 문제점을 확인해보자.

```java
  @Test
    @DisplayName("스프링 없는 순수한 DI 컨테이너")
    void pureContainer() {
        AppConfig appConfig = new AppConfig();

        //조회1 : 호출할 때마다 객체 생성
        MemberService memberService1 = appConfig.memberService();

        //조회2 : 호출할 때마다 객체 생성
        MemberService memberService2 = appConfig.memberService();

        //참조값이 다른것을 확인
        System.out.println("memberService1 = " + memberService1);
        System.out.println("memberService2 = " + memberService2);
    }
```

순수한 DI 컨테이너인 `AppConfig`를 사용하게 된다면 고객이 요청할 때 마다 새로운 객체가 생성되고 소멸된다.

이렇게 된다면 고객이 요청할 때마다 JVM 메모리에 객체가 계속 생성되고 소멸 될것이다. (메모리 낭비)

해결방법으로는 고객이 요청시 할 때 마다 객체가 매번 생성되는것이 아닌 하나의 객체를 생성하여 공유하도록 설계하면 될것이다.

<br>

#### 싱글톤 패턴

> 싱글톤 패턴은 쉽게말하여 객체 인스턴스가 하나만 생성되는것을 보장하는 패턴이다.

싱글톤 패턴을 구현하는 방법으로는 여러가지 방법이 존재한다.

- 이른 초기화 방법 : 클래스 로딩 시점에 인스턴스를 미리 생성하는 방식
  
```java
public class SingletonService {
    private static final SingletonService instance = new SingletonService();

    private SingletonService() {
    }

    public static SingletonService getInstance() {
        return instance;
    }

    public void logic() {
        System.out.println("singleton instance logic call");
    }

}
```

싱글톤 패턴을 적용하면 고객의 요청에 대해 매번 새로운 객체를 생성하는것이 아닌 이미 만들어진 객체를 공유하여 효율적으로
사용할 수 있지만 여러가지 문제점이 있다.

<br>

**싱글톤 패턴의 문제점**
- 싱글톤 구현 코드 -> 매번 작성하기 번거로움
- DIP 위반
- OCP 위반
- 테스트 하기 어렵다
- 내부 속성을 변경하거나 초기화 하기 어렵다.
- private로 자식 클래스를 만들기 어렵다.
- 유연성이 떨어짐

<br>

**스프링 컨테이너는 위에 말했던 문제점을 모두 해결하고 등록된 빈들을 싱글톤으로 관리되는것을 보장해준다.**
- 스프링 컨테이너가 싱글톤으로 관리할 수 있는 이유는 `@Configuration` 어노테이션에 있다.
  - `@Configuration` 은 CGLIB 이라는 바이트 코드 조작 라이브러리를 사용한다.
  - CGLIB 라이브러리를 사용하여 설정 정보 클래스인 `AppConfig` 클래스를 상속받은 임의의 다른 클래스를 생성한다.
  - CGLIB을 통해 만들어진  `AppConfig@CGLIB` 이라는 클래스를 스프링 빈으로 등록하게된다.
  - `AppConfig@CGLIB` 클래스가 싱글톤이 보장되도록 한다.

<br>

**AppConfig@CGLIB 예상 코드**

```java
@Bean
public MemberRepository memberRepository() {
	if (memberRepositry가 이미 스프링 컨테이너에 등록되 있으면?) {
		return 스프링 컨테이너에서 찾아서 반환;
	} else {
		기존 로직을 호출하여 반환 객체를 스프링 컨테이너에 등록
		reteurn 반환
	}
}
```
- `@Bean` 어노테이션이 붙은 메서드를 호출하며 이미 스프링 컨테이너 등록된 빈이 있으면 등록된 빈을 반환.
- 등록된 빈이 없다면 스프링 빈으로 등록하고 반환할 것이다.

<br>

---

<br>

### 📌 컴포넌트 스캔

- 지금까지 AppConfig 클래스에 직접 `@bean` 으로 클래스를 등록하고 의존관계를 명시적으로 등록하였다.
- 예제에서는 몇개 안되서 문제가 없지만 등록해야할 클래스가 많아진다면 개발자는 번거로워 진다.
- 스프링에서는 설정 정보가 없어도 자동으로 스프링 빈을 등록해주는 **컴포넌트 스캔** 이라는 기능을 지원한다.

<br>

컴포넌트 스캔은 패키지를 검색하며 `@Component` 어노테이션이 붙은 클래스를 스프링 컨테이너에 등록하는 기능이다. 

<br>

**AutoAppConfig.java**
```java
@Configuration
@ComponentScan
public class AutoAppConfig {}
```
- 설정 파일로 사용할 클래스에 `@ComponentScan` 어노테잏션을 사용하면 컴포넌트 스캔 기능을 사용할 수 있다.
- 기존 AppConfig 클래스와 달리 `@Bean` 으로 등록한 클래스가 하나도 없다.

<br>

**@Component 어노테이션**
```java
@Component
public class MemberServiceImpl implements MemberService

@Component
public class MemoryMemberRepository implements MemberRepository

@Component
public class OrderServiceImpl implements OrderService
...
```
- @ComponentScan은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- @ComponentScan의 대상이 되기 위해서는 등록하려는 클래스에 @Component 어노테이션을 붙여주면 된다.

<br>

**그렇다면 컴포넌스 스캔은 모든 패키지를 검색하며 @Component 어노테이션이 붙은 클래스를 검색하는 것일까?**

- 개발자가 따로 지정하지 않은 경우 `ComponentScan` 이 붙은 설정 정보 클래스부터 하위로 검색한다.
  - ex) AutoAppConfig 클래스의 위치가 package com.hello.core  이므로 core 부터 하위로 검색하게 된다.
- 컴포넌트 스캔을 임의로 필요한 위치부터 검색할 수 있도록 변경할 수 있다.
  - basePackages : 탐색할 패키지의 시작 위치를 지정한다.  패키지를 포함하여 하위로 검색한다.
  - basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다

<br>

**의존관계 주입은?**

기존에는 설정 클래스에 `@Bean` 으로 클래스를 등록하면서 의존관계도 명시해주었다.

하지만 컴포넌트 스캔을 사용하면서 명시적으로 의존관계를 주입할 방법이 없다. @AutoWired를 사용하자.\

<br>

**@AutoWired 어노테이션 사용**
```java
    @Autowired
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
```

- 컴포넌트 스캔은 @Component 가 붙은 모든 클래스를 스프링 빈으로 등록한다.
- 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자는 소문자를 사용한다.
  - 스프링 빈의 이름은 개발자가 직접 지정도 가능하다. `@Component("hello")`
- @Autowired 를 사용한 메서드나, 필드에 스프링 컨테이너가 자동으로 스프링 빈을 찾아서 주입해준다.
  - 기본적으로 타입이 같은 빈을 찾아서 주입해준다.

<br>

필터 기능을 사용하면 컴포넌트 스캔 대상을 추가하거나 제외할 수 도 있다.
- includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
- excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

<br>

**AutoAppConfig.java**
```java
@Configuration
    @ComponentScan(
            includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
            excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
    )
    static class ComponentFilterAppConfig{
}
```

<br>

**컴포넌트 스캔에서 같은 빈 이름을 등록하면?**

- 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데 이름이 같을 경우 스프링은 오류 발생
  - `ConflictingBeanDefinitionException` 발생
- 기본적으로 수동빈이 우선권을 갖지만 최근에는 스프링부트가 오류가 발생하도록 변경하였다.

<br>

---

<br>

### 📌 의존관계 자동 주입

의존관계 주입은 크게 4가지 방법이 있다.
- 생성자 주입
- 수정자 주입
- 메서드 주입
- 필드 주입

<br>

**생성자 주입**

- 객체가 생성될 때 해당 클래스의 생성자를 호출하여 의존 관계를 주입하는 방식이다.
- 생성자를 통해 의존관계가 주입되므로 딱 **1번만 호출되는것**을 보장한다.
- **불변, 필수** 의존관계에 사용된다.

<br>

**수정자 주입**

- 객체를 먼저 생성후 스프링 컨테이너가 해당 객체의 Setter 메서드를 호출하여 의존관계를 주입하는 방식이다.
- 선택, 변경 가능성이 있는 의존관계에서 사용된다.
  - Setter 메서드를 통해 의존관계를 변경 할 수 있기 때문.

<br>

**메서드 주입**

- 객체 생성후 스프링 컨테이너가 `@Autowired` 붙은 메서드를 실행하여 의존관계를 주입하는 방식이다.
- 한번에 여러 필드를 주입받을 수 있다는 장점이 있다.

<br>

**필드 주입**

- 객체 생성후 해당 객체의 필드에 직접 주입하는 방식이다.
- 코드가 간결하게보일 수 있지만 외부에서 변경할 방법이 없어 테스트가 힘들다는 단점이있다.
- DI 프레임 워크가 없으면 아무것도 할 수 없다.

<br>

#### 옵션처리
`@Autowired` 만 사용하면 `required` 의 값이 `ture` 이기 때문에 자동 주입 대상이 없으면 오류가 발생

<br>

**자동 주입할 대상을 옵션으로 처리하는 방법**
- `@Autowired(required=false)`  : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출되지 않는다.
- `@Nullable` : 자동 주입할 대상이 없으면  null 값
- `Optional<>` : 자동 주입할 대상이 없으면 Optional.empty

<br>

**TeseBean.java**

```java
     @Autowired(required = false) // 호출 X
        public void setNoBean1(Member noBean1) {
            System.out.println("noBean1 = " + noBean1);
        }

        @Autowired //noBean2 = null
        public void setNoBean2(@Nullable Member noBean2) {
            System.out.println("noBean2 = " + noBean2);
        }

        @Autowired // noBean3 = Optional.empty
        public void setNoBean3(Optional<Member> noBean3) {
            System.out.println("noBean3 = " + noBean3);
        }
```

<br>

**생성자 주입 권장**
- 대부분 의존관계는 한 번 주입하면 애플리케이션 종료 시점까지 의존관계를 변경할 일이 없다.
- 대부분 의존관계는 애플리케이션 종료 시점까지 변하면 안된다 → 불변
- 수정자 주입을 사용하면 Setter 메서드를 public으로 열어두어야한다 → 실수 할 수 있다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 실행되므로 이후 호출 X → 불변하다.
- 프레임워크에 의존하지 않고 순수한 자바 언어 특징을 잘살리는 방법이다.