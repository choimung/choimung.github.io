---
title: 그리디 알고리즘 문제(숫자 카드 게임)
date: 2023-07-19 22:48:00 +0900
categories: [Algorithm, Greedy]
tags: [github blog,algorithm,greedy]
toc: true
toc_sticky: true
toc_label: 목차
math: true
mermaid: true
---

## 서론

### 그리디 알고리즘 개요
그리디 알고리즘(또는 탐욕 알고리즘)은 각 단계에서 가장 최적인 선택을 하는 알고리즘 설계기법입니다.
그리디 알고리즘은 해당 단계에서 가장 좋은 선택을 하여 전체적인 결과를 얻으려는 접근 방식을 가지고 있습니다.

### 문제의 목표 설명
- 문제 설명 : 숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한 장을 뽑는 게임입니다.


- 제약 조건 : 

                1. 숫자가 쓰인 카드들이 n * m 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며 M은 열의 개수를 의미한다.

                2. 먼저 뽑고하 하는 카드가 포함되어 있는 행을 선택한다.

                3. 그다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.

                4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을고려하여

                최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야한다.


<br>

## 문제 이해와 분석
예를 들어 3 * 3 형태로 카드들이 다음과 같이 놓여있다고 가정합니다.

3 1 2

4 1 4

2 2 2

여기서 첫 번째행과 두 번째 행을 선택할 경우 최종적으로 뽑는카드는 2이다.
하지만 세 번째 행을 선택하는 경우 최정적으로 뽑는 카드는 2이다. 따라서 이 예제에서는 세 번째 행을 선택하여 2가 쓰여진카드를 뽑는 것이 정답이다.

각 행마다 가장 작은 수 를 찾은뒤에 그 수 중에서 가장큰수를 찾으면 될거같습니다.
<br>

## 알고리즘 설계

### 접근방식
저는 아래와 같이 문제에 접근하였습니다.
1. 변수 min_value을 생성하고 초기화를 해줍니다.
2. 2중 반복문을 이용하여 각 행의 가장 작은 값을 비교하여 변수에 저장합니다.
3. 2중 반복문을 탈출하게 되면 min 값과 각 행의 가장 작은 값을 비교 행의 값이 클 경우 min값에 대입연산을 진행합니다.
4. 그렇게 행의 길이 만큼 2,3번 과정을 반복하여줍니다.

<br>
## 알고리즘 구현

>제가 작성한 코드는 아래와 같습니다.

```java

public class main {
    public static void main(String[] args) {
        int[][] arr = new int[][]{
                {3,1,2},
                {4,4,4},
                {2,2,2}
        };
        int result = 0;


        for(int i = 0; i < arr.length; i++){
            int min_value = Integer.MAX_VALUE;
            for(int j = 0; j<arr[i].length; j++){
                if(arr[i][j] < min_value){
                    min_value = arr[i][j];
                }
            }
            if(min_value > result){
                result = min_value;
            }
        }
        System.out.println(result);
    }

}

```
<br>

## 최적화와 시간복잡도

### 최적화
![](../../../assets/img/2023-07-19-23-18-41.png)

### 시간 복잡도
현재 주어진 코드는 2차원 배열에서 각 행의 최소값들을 구하고, 그 중에서 가장 큰 값을 찾아내는데, 이를 위해 모든원소를 한번씩 방문하므로
O(N*M)의 시간 복잡도를 가집니다.

<br>

## 마무리